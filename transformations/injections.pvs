% A protocol injection is less restrictive than a protocol
% transformation.  Every protocol transformation is a protocol
% injection, but not vice versa.

% To compare two protocols src and dst, try to prove
%
%     source_goals_implied?(src, dst),
%
% which is defined at the end of this theory.

% John D. Ramsdell -- The MITRE Corporation -- October 2014

% Copyright (C) 2014 The MITRE Corporation.
% All rights reserved.
% See ../license.txt for terms.

injections: theory
begin

  skeletons: library = "../skeletons"
  importing skeletons@roles
  importing increasing

  % A trace map is an increasing function that respects event orientation
  tmap?(c0, c1: trace)(f: (increasing?(c0`length, c1`length))): bool =
    subset?(param?(c0), param?(c1)) and
    forall(i: below[c0`length]):
      recv?(c0(i)) iff recv?(c1(f(i)))

  tmap(c0, c1: trace): type = (tmap?(c0, c1))

  strand_increasing(src, dst: strand_space): type =
    (increasing?(src`length, dst`length))

  % The maximum of a nonempty set.
  setmax(s: non_empty_finite_set[nat]): nat =
    epsilon!(x: (s)): forall(y: (s)): y <= x

  % An injection
  inj(src, dst: protocol): type =
    [s: (src) -> [d: (dst), tmap(s`trace, d`trace)]]

  % Does dst import the goals of src via injection f?
  imported_goals_of?(src, dst: protocol)(f: inj(src, dst)): bool =
    forall(bd: bundle, pad: protocol_assignment(dst, bd)):
      exists(bs: bundle, pas: protocol_assignment(src, bs),
             g: strand_increasing(bs`space, bd`space)):
        let i(n: node(bs`space)) = (g(n`1), f(pas(n`1))`2(n`2)) in

            % Roles respect injection (for strand progress predicate mappings)
        (forall(zs: strand(bs`space), zd: strand(bd`space)):
          g(zs) = zd implies
            f(pas(zs))`1 = pad(zd) and
            instantiate(pas(zs)`trace, bs`space(zs)`length,
              down(instance(pad(zd)`trace, bd`space(zd)))) = bs`space(zs))

        % and % Nodes respect injection (for strand progress predicate heights)
        %   (forall(zs: strand(bs`space)):
        %     let set(i: below[length(bs`space(zs))]): bool =
        %       f(pas(zs))`2(i) < length(bd`space(g(zs))) in
	%     length(bs`space(zs)) = 1 + setmax(set))

        % and % Source communication edges repect injection
        %     % (for node ordering predicate)
        %   (forall(n0, n1: node(bs`space)):
        %     bs`comm(n0, n1) iff
        %       exists(n2, n3: node(bd`space)):
        %         i(n0) = n2 and
        %         i(n1) = n3 and
        %         bd`comm(n2, n3))

        % and % Non-origination predicate respects injection
        %   (forall(x: (atoms(bs`space))):
        %     non(bd`space)(x) implies non(bs`space)(x))

        % and % Unique origination predicate respects injection
        %   (forall(x: (atoms(bs`space)), n: node(bs`space)):
        %     uniq(bd`space)(x, i(n)) implies
        %       uniq(bs`space)(x, n))

end injections
