% Roles as sets

% John D. Ramsdell -- The MITRE Corporation -- December 2012

% Recall that in CPSA, a message algebra is a free, order sorted
% quotient term algebra generated by finite sets of message variables.
% The message algebra used in this library is an initial algebra, as
% in bundles, there are no message variables.

% In CPSA, a role includes a trace that is used as a template for
% strands instantiated from the role.  In particular, the message
% variables in the trace are mapped into messages in the strand to
% establish that the strand is an instance of the given role.  The
% lack of message variables makes the concept of role traces as a
% template unworkable.

% Given the absence of message variables, a PVS role is a set of role
% items.  Each role item includes a trace, non- and uniquely
% originating assumptions, and annotations.  A strand is an instance
% of a role if there exists a role item in the role that matches it.
% The function item_instance? defines the criteria for the match.

% Copyright (C) 2014 The MITRE Corporation.
% All rights reserved.
% See ../license.txt for terms.

roles[mesg: type, carried_by?: [mesg, mesg -> bool]]: theory
begin

  importing bundles[mesg, carried_by?]

  % Assumptions are used to associate a set of messages with each
  % position in a trace.  The purpose of assumptions is defined below
  % in item_instance?.

  assumptions: type = nonempty_finite_sequence[setof[mesg]]

  % A role will be a set of role items with conditions.
  role_item: type = [# trace:   trace,
                       rnon:    {c: assumptions |  % Non-origination
                                 length(c) = length(trace)},
                       runique: {c: assumptions |  % Unique origination
                                 length(c) = length(trace)} #]

  % Handle special case in which there are no role origination assumptions

  no_assumptions(n: posnat): recursive assumptions =
    if n = 1 then
      singleton_seq(emptyset)
    else
      add(emptyset, no_assumptions(n - 1))
    endif
    measure n

  no_assumptions_length: lemma
    forall(n: posnat): length(no_assumptions(n)) = n

  auto_rewrite+ no_assumptions_length

  no_assumptions?(c: assumptions): bool =
    forall(i: index(c)): empty?(c(i))

  has_no_assumptions: lemma
    forall(n: posnat): no_assumptions?(no_assumptions(n))

  has_empty_assumptions: lemma
    forall(n: posnat, i: below[n]):
      empty?(no_assumptions(n)(i))

  % A simple role item has only a trace
  simple_role_item(c: trace): role_item =
    (# trace   := c,
       rnon    := no_assumptions(c`length),
       runique := no_assumptions(c`length) #)

  % New defs

  % Is strand s in bundle b an instance of role item ri?
  inst(b: bundle)(s: strand(b`space), ri: role_item): bool =
    prefix?[event](b`space(s), ri`trace) and
    let h = b`space(s)`length in      % The height of the strand
    (forall(j: below(h)):             % Inherited nons don't originate
      forall(m: (ri`rnon(j))): non(b`space)(m)) and
    (forall(j: below(h)):             % Inherited uniques originate once
      forall(m: (ri`runique(j))): uniq(b`space)(m, (s, j)))

  pred(b: bundle)(s: strand(b`space), h: nat, ri: role_item): bool =
    inst(b)(s, ri) and h <= b`space(s)`length

  % Inherited non-origination assumptions at a node
  strand_inherits_non: lemma
    forall(b: bundle, ri: role_item, m: mesg,
           s: strand(b`space), i: index(b`space(s))):
      inst(b)(s, ri) and member(m, ri`rnon(i)) implies non(b`space)(m)

  % Inherited unique origination assumptions at a node
  strand_inherits_unique: lemma
    forall(b: bundle, ri: role_item, m: mesg,
           s: strand(b`space), i: index(b`space(s))):
      inst(b)(s, ri) and member(m, ri`runique(i)) implies
        uniq(b`space)(m, (s, i))

  simple_inst: lemma
    forall(b: bundle, s: strand(b`space), c: trace):
      inst(b)(s, simple_role_item(c)) = prefix?[event](b`space(s), c)

  auto_rewrite+ simple_inst

  simple_inst_non: lemma
    forall(b: bundle, n: node(b`space), c: trace):
      inst(b)(n`1, simple_role_item(c)) implies
        empty?(simple_role_item(c)`rnon(n`2))

  simple_inst_unique: lemma
    forall(b: bundle, n: node(b`space), c: trace):
      inst(b)(n`1, simple_role_item(c)) implies
        empty?(simple_role_item(c)`runique(n`2))

  role: type = setof[role_item]

  % This definition is troubling because a role may contain
  % role_item's with traces that differ in length!  It would semem it
  % should be:

  % role?(r: setof[role_item]): bool =
  %   forall(ri0, ri1: (r)):
  %     ri0`trace`length = ri1`trace`length

  % role: type = (role?)

  % On the other hand, when the current definition is used with roles
  % that all contain role items with traces of the same length,
  % everything seems to work out right.

  role_pred(b: bundle)(s: strand(b` space), h: nat, r: role): bool =
    exists(ri: (r)): pred(b)(s, h, ri)

  pre_role_assignment(b: bundle): type = [strand(b`space) -> role]

  % Function ra is a role assignment for bundle b if each trace is an
  % instance of the assigned role.
  role_assignment?(b: bundle)(ra: pre_role_assignment(b)): bool =
    forall(s: strand(b`space)):
      exists(ri: (ra(s))): inst(b)(s, ri)

  role_assignment(b: bundle): type = (role_assignment?(b))

  % Protocols

  protocol: type = finite_set[role]

  % The range of the role assignment is the protocol
  protocol_assignment?(p: protocol)(b: bundle)(ra: role_assignment(b)): bool =
    forall(s: strand(b`space)): member(ra(s), p)

  protocol_assignment(p: protocol, b: bundle): type =
    (protocol_assignment?(p)(b))

  % Bundle b is a run of protocol p if there exists a protocol assignment
  run?(p: protocol)(b: bundle): bool =
    exists(pa: protocol_assignment(p, b)): true

  % The obvious lemma about bundles with protocol assigments and runs:
  bundles_with_assignments_are_runs: lemma
    forall(p: protocol, b: bundle, pa: protocol_assignment(p, b)):
      run?(p)(b)

  run(p: protocol): type = (run?(p))

end roles
