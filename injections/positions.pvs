% Positions in message algebra terms

% John D. Ramsdell -- The MITRE Corporation -- September 2014

% Copyright (C) 2014 The MITRE Corporation.
% All rights reserved.
% See ../license.txt for terms.

positions: theory
begin

  strand_spaces: library = "../strand_spaces"
  importing strand_spaces@init_alg

  % The direction when traversing a binary term
  direction: datatype
  begin
    left: left?
    right: right?
  end direction

  pre_position: type = finite_sequence[direction]

  % A position navigates through binary terms to denote a term
  position?(m: mesg)(p: pre_position): recursive bool =
    p`length = 0 or
    cases m of
      pr(f, s):
        cases p(0) of
	  left: position?(f)(p ^^ (1, p`length)),
	  right: position?(s)(p ^^ (1, p`length))
        endcases,
      en(t, k):
        cases p(0) of
	  left: position?(t)(p ^^ (1, p`length)),
	  right: position?(k)(p ^^ (1, p`length))
        endcases
      else
        false
    endcases
    measure m by <<

  position(m: mesg): type = (position?(m))

  % The term at a given position
  term_at(m: mesg, p: position(m)): recursive mesg =
    if p`length = 0 then
      m
    else
      cases m of
        pr(f, s):
          cases p(0) of
 	    left: term_at(f, p ^^ (1, p`length)),
	    right: term_at(s, p ^^ (1, p`length))
          endcases,
        en(t, k):
          cases p(0) of
	    left: term_at(t, p ^^ (1, p`length)),
	    right: term_at(k, p ^^ (1, p`length))
          endcases
      endcases
    endif
    measure m by <<

  same_form?(m0, m1: mesg): recursive bool =
    cases m0 of
      pr(f0, s0):
        cases m1 of
          pr(f1, s1):
            same_form?(f0, f1) and same_form?(s0, s1)
          else
            false
          endcases,
      en(t0, k0):
        cases m1 of
          en(t1, k1):
            same_form?(t0, t1) and same_form?(k0, k1)
          else
            false
          endcases
      else
        not pair?(m1) and not enc?(m1)
    endcases
    measure m0 by <<

end positions
