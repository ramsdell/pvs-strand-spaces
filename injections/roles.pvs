% Roles as sets with the template restriction

% John D. Ramsdell -- The MITRE Corporation -- September 2014

% Recall that in CPSA, a message algebra is a free, order sorted
% quotient term algebra generated by finite sets of message variables.
% The message algebra used in this library is an initial algebra, as
% in bundles, there are no message variables.

% In CPSA, a role includes a trace that is used as a template for
% strands instantiated from the role.  In particular, the message
% variables in the trace are mapped into messages in the strand to
% establish that the strand is an instance of the given role.  The
% lack of message variables makes the concept of role traces as a
% template unworkable.

% Given the absence of message variables, a PVS role is a set of role
% items.  Each role item includes a trace, non- and uniquely
% originating assumptions, and annotations.  A strand is an instance
% of a role if there exists a role item in the role that matches it.
% The function item_instance? defines the criteria for the match.

% This version enforces the restriction that roles satisfy the
% template condition.  See role? for its definition.

% Copyright (C) 2014 The MITRE Corporation.
% All rights reserved.
% See ../license.txt for terms.

roles[mesg: type, carried_by?: [mesg, mesg -> bool],
      same_form?: [mesg, mesg -> bool]]: theory
begin

  strand_spaces: library = "../strand_spaces"
  importing strand_spaces@bundles[mesg, carried_by?]

  % Assumptions are used to associate a set of messages with each
  % position in a trace.  The purpose of assumptions is defined below
  % in item_instance?.

  assumptions: type = nonempty_finite_sequence[setof[mesg]]

  % A role will be a set of role items with conditions.
  role_item: type = [# trace:   trace,
                       rnon:    {c: assumptions |  % Non-origination
                                 length(c) = length(trace)},
                       runique: {c: assumptions |  % Unique origination
                                 length(c) = length(trace)} #]

  % Handle special case in which there are no role origination assumptions

  no_assumptions(n: posnat): recursive assumptions =
    if n = 1 then
      singleton_seq(emptyset)
    else
      add(emptyset, no_assumptions(n - 1))
    endif
    measure n

  no_assumptions_length: lemma
    forall(n: posnat): length(no_assumptions(n)) = n

  auto_rewrite+ no_assumptions_length

  no_assumptions?(c: assumptions): bool =
    forall(i: index(c)): empty?(c(i))

  has_no_assumptions: lemma
    forall(n: posnat): no_assumptions?(no_assumptions(n))

  has_empty_assumptions: lemma
    forall(n: posnat, i: below[n]):
      empty?(no_assumptions(n)(i))

  % A simple role item has only a trace
  simple_role_item(c: trace): role_item =
    (# trace   := c,
       rnon    := no_assumptions(c`length),
       runique := no_assumptions(c`length) #)

  % New defs

  % Is strand s in bundle b an instance of role item ri?
  inst(ss: strand_space)(s: strand(ss), ri: role_item): bool =
    prefix?[event](ss(s), ri`trace) and
    let h = ss(s)`length in      % The height of the strand
    (forall(j: below(h)):             % Inherited nons don't originate
      forall(m: (ri`rnon(j))): non(ss)(m)) and
    (forall(j: below(h)):             % Inherited uniques originate once
      forall(m: (ri`runique(j))): uniq(ss)(m, (s, j)))

  pred(ss: strand_space)(s: strand(ss), h: nat, ri: role_item): bool =
    inst(ss)(s, ri) and h <= ss(s)`length

  % Inherited non-origination assumptions at a node
  strand_inherits_non: lemma
    forall(ss: strand_space, ri: role_item, m: mesg,
           s: strand(ss), i: index(ss(s))):
      inst(ss)(s, ri) and member(m, ri`rnon(i)) implies non(ss)(m)

  % Inherited unique origination assumptions at a node
  strand_inherits_unique: lemma
    forall(ss: strand_space, ri: role_item, m: mesg,
           s: strand(ss), i: index(ss(s))):
      inst(ss)(s, ri) and member(m, ri`runique(i)) implies
        uniq(ss)(m, (s, i))

  simple_inst: lemma
    forall(ss: strand_space, s: strand(ss), c: trace):
      inst(ss)(s, simple_role_item(c)) = prefix?[event](ss(s), c)

  auto_rewrite+ simple_inst

  simple_inst_non: lemma
    forall(ss: strand_space, n: node(ss), c: trace):
      inst(ss)(n`1, simple_role_item(c)) implies
        empty?(simple_role_item(c)`rnon(n`2))

  simple_inst_unique: lemma
    forall(ss: strand_space, n: node(ss), c: trace):
      inst(ss)(n`1, simple_role_item(c)) implies
        empty?(simple_role_item(c)`runique(n`2))

  % Role items must agree on their length and the form of each message
  % in their traces.
  role?(r: setof[role_item]): bool =
    forall(ri0, ri1: (r)):
      ri0`trace`length = ri1`trace`length and
      forall(i: index(ri0`trace)):
        same_form?(t(ri0`trace(i)), t(ri1`trace(i)))

  role: type = (role?)

  role_pred(ss: strand_space)(s: strand(ss), h: nat, r: role): bool =
    exists(ri: (r)): pred(ss)(s, h, ri)

  pre_role_assignment(b: bundle): type = [strand(b`space) -> role]

  % Function ra is a role assignment for bundle b if each trace is an
  % instance of the assigned role.
  role_assignment?(b: bundle)(ra: pre_role_assignment(b)): bool =
    forall(s: strand(b`space)):
      exists(ri: (ra(s))): inst(b`space)(s, ri)

  role_assignment(b: bundle): type = (role_assignment?(b))

  % Protocols

  protocol: type = finite_set[role]

  % The range of the role assignment is the protocol
  protocol_assignment?(p: protocol)(b: bundle)(ra: role_assignment(b)): bool =
    forall(s: strand(b`space)): member(ra(s), p)

  protocol_assignment(p: protocol, b: bundle): type =
    (protocol_assignment?(p)(b))

  % Bundle b is a run of protocol p if there exists a protocol assignment
  run?(p: protocol)(b: bundle): bool =
    exists(pa: protocol_assignment(p, b)): true

  % The obvious lemma about bundles with protocol assigments and runs:
  bundles_with_assignments_are_runs: lemma
    forall(p: protocol, b: bundle, pa: protocol_assignment(p, b)):
      run?(p)(b)

  run(p: protocol): type = (run?(p))

end roles
