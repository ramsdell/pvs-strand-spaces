% A protocol injection is less restrictive than a protocol
% transformation.  Every protocol transformation is a protocol
% injection, but not vice versa.

% To compare two protocols src and dst, try to prove
%
%     source_goals_implied?(src, dst),
%
% which is defined at the end of this theory.

% John D. Ramsdell -- The MITRE Corporation -- October 2014

% Copyright (C) 2014 The MITRE Corporation.
% All rights reserved.
% See ../license.txt for terms.

injections: theory
begin

  skeletons: library = "../skeletons"
  importing skeletons@roles
  importing increasing

  % A trace map is an increasing function that respects event orientation
  tmap?(c0, c1: trace)(f: (increasing?(c0`length, c1`length))): bool =
    forall(i: below[c0`length]):
      recv?(c0(i)) iff recv?(c1(f(i))) and
      subset?(param?(c0 ^ (0, i)), param?(c1 ^ (0, f(i))))

  tmap(c0, c1: trace): type = (tmap?(c0, c1))

  strand_increasing(src, dst: strand_space): type =
    (increasing?(src`length, dst`length))

  % An injection
  inj(src, dst: protocol): type =
    [s: (src) -> [d: (dst), tmap(s`trace, d`trace)]]

  % Does dst import the goals of src via injection f?
  imported_goals_of?(src, dst: protocol)(f: inj(src, dst)): bool =
    forall(bd: bundle, pad: protocol_assignment(dst, bd)):
      exists(bs: bundle, pas: protocol_assignment(src, bs),
             g: strand_increasing(bs`space, bd`space)):

            % Roles respect injection (for strand progress predicate mappings)
        (forall(zs: strand(bs`space), zd: strand(bd`space)):
          g(zs) = zd implies
            f(pas(zs))`1 = pad(zd) and
            instantiate(pas(zs)`trace, bs`space(zs)`length,
              down(instance(pad(zd)`trace, bd`space(zd)))) = bs`space(zs))

        and 
        let i(n: node(bs`space)): [strand(bd`space), 
                                   below[length(pad(g(n`1))`trace)]] =
             (g(n`1), f(pas(n`1))`2(n`2)) in
            % Nodes respect injection (for strand progress predicate heights)
          (forall(ns: node(bs`space)):
            exists(nd: node(bd`space)):
              i(ns) = nd)

        and % Source communication edges repect injection
            % (for node ordering predicate)
          (forall(n0, n1: node(bs`space)):
            bs`comm(n0, n1) iff
              exists(n2, n3: node(bd`space)):
                i(n0) = n2 and
                i(n1) = n3 and
                bd`comm(n2, n3))

        and % Non-origination predicate respects injection
          (forall(x: (atoms(bs`space))):
            non(bd`space)(x) implies non(bs`space)(x))

        and % Unique origination predicate respects injection
          (forall(x: (atoms(bs`space)), n: node(bs`space)):
            uniq(bd`space)(x, i(n)) implies
              uniq(bs`space)(x, n))

end injections
