\documentclass[12pt]{article}

\newif\ifreleased
\releasedtrue % \releasedfalse

% For drafts:
\ifreleased
\else
\pagestyle{myheadings}
\markright{Draft of \today{}}
\fi
%\renewcommand{\pagename}{Draft of \today{}, Page}

%\usepackage{graphics}
%\usepackage[matrix,arrow,curve]{xy}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{url}
\usepackage{hyperref}\hypersetup{colorlinks=true,}

\newenvironment{note}{\begingroup\itshape}{\endgroup}
\newcommand{\remark}[1]{\emph{[#1]}}
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{conj}[thm]{Conjecture}
\newcommand{\cpsa}{\textsc{cpsa}}
\newcommand{\pvs}{\textsc{pvs}}
\newcommand{\cn}[1]{\ensuremath{\operatorname{\mathsf{#1}}}}
\newcommand{\dom}[1]{\ensuremath{\operatorname{\mathbf{#1}}}}
\newcommand{\fn}[1]{\ensuremath{\operatorname{\mathit{#1}}}}
\newcommand{\srt}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\typ}{\mathbin:}
\newcommand{\sdom}{\fn{Dom}}
\newcommand{\sran}{\fn{Ran}}
\newcommand{\vars}{\fn{Vars}}
\newcommand{\seq}[1]{\ensuremath{\langle#1\rangle}}
\newcommand{\prefix}[2]{#1\dagger#2}
\newcommand{\append}{\cdot}
\newcommand{\enc}[2]{\ensuremath{\{\!|#1|\!\}_{#2}}}
\newcommand{\invk}[1]{{#1}^{-1}}
\newcommand{\inbnd}{\mathord -}
\newcommand{\outbnd}{\mathord +}
\newcommand{\nat}{\ensuremath{\mathbb{N}}}
\newcommand{\zed}{\ensuremath{\mathbb{Z}}}
\newcommand{\all}[1]{\forall#1\mathpunct.}
\newcommand{\some}[1]{\exists#1\mathpunct.}
\newcommand{\funct}[1]{\lambda#1\mathpunct.}
\newcommand{\dprod}[1]{\Pi_{(#1)}}
\newcommand{\dpair}[1]{\Sigma_{(#1)}}
\newcommand{\pow}[1]{\wp(#1)}

\newcommand{\alg}[1]{\ensuremath{\mathfrak{#1}}}
\newcommand{\msg}{\alg{A}}
\newcommand{\atm}{\alg{B}}
\newcommand{\ssp}{\ensuremath{\mathcal{S}}}
\newcommand{\bun}{\ensuremath{\mathcal{B}}}
\newcommand{\strands}{\ensuremath{\mathcal{Z}}}
\newcommand{\nodes}{\ensuremath{\mathcal{N}}}
\newcommand{\pos}{\ensuremath{\mathcal{P}}}

\newcommand{\run}{\mathcal{R}}
\newcommand{\pt}{\fn{pt}}
\newcommand{\form}{\mathcal{K}}
\newcommand{\sent}{\mathcal{S}}
\newcommand{\lang}{\mathcal{L}}
\newcommand{\interp}{\mathcal{I}}
\newcommand{\tr}{\ensuremath{\mathfrak C}}
\newcommand{\rl}{\ensuremath{\rho}}
\newcommand{\skel}{\mathsf{k}}
\newcommand{\insta}{\mathsf{i}}
\newcommand{\insts}{\mathcal{I}}
\newcommand{\evt}{\fn{evt}}
\newcommand{\role}{\mathsf{r}}
\newcommand{\orig}{\mathcal{O}}

\newcommand{\sembrack}[1]{[\![#1]\!]}

\title{Protocol Injections}
\author{John D.\ Ramsdell}
%\institute{The MITRE Corporation}

\begin{document}
\maketitle

\section{Introduction}

This paper introduces protocol injections.  Protocol injections are
related to protocol transformations~\cite{Guttman12a} as shape
analysis sentences~\cite{Ramsdell12} are related to security goals as
defined in~\cite{Guttman12a}.  The precise relation between protocol
injections and transformations has yet to be established.

Protocol injections can be used to decide if the security goals of one
protocol are imported into another.  The definition of goal
importation defined in Section~\ref{sec:protocol injections} ensures
that the truth of predicates used in shape analysis sentences is
preserved.

\paragraph{Notation.}

A finite sequence~$f$ is a function from an initial segment of the
natural numbers.  The length of~$f$ is~$|f|$, and $f=\seq{f(0),\ldots,
  f(n-1)}$ for $n=|f|$.  If~$S$ is a set, then~$S^\ast$ is the set of
finite sequences over~$S$, and~$S^+$ is the non-empty finite sequences
over~$S$.  The concatenation of sequences~$f_0$ and~$f_1$
is~$f_0\append f_1$.  The prefix of sequence~$f$ of length~$n$
is~$\prefix{f}{n}$.

{\pvs} is based on classical, typed higher-order
logic.  It has dependent types and parameterized theories.
The dependent product type~$\dprod{x\in A}B(x)$ has the property that
$f\in\dprod{x\in A}B(x)$ implies that for~$x\in A$, $f(x)\in B(x)$.
The dependent pair type~$\dpair{x\in A}B(x)$ has the property that
$(x,y)\in\dpair{x\in A}B(x)$ implies that~$x\in A$ and~$y\in B(x)$.

\section{Strand Spaces}\label{sec:strand spaces}

Based on~\cite{cpsaspec09}, this section describes the {\pvs}
definition of strand spaces~\cite{ThayerHerzogGuttman99} in a style
motivated by the {\pvs} language~\cite{cade92-pvs}, that is, the
presentation attempts to minimize the gap between the actual proofs
and this content.

The parameters to the strand space theory are a set of messages
(\msg), a set of atoms ($\atm\subset\msg$), and a carried by relation
(${\sqsubseteq}\subseteq\msg\times\msg$).  The set of messages~{\msg}
is the carrier set of a term algebra.  Keys and nonces are examples of
atoms.  Intuitively, a message~$t_0$ is carried by~$t_1$
($t_0\sqsubseteq t_1$) if it is possible to extract~$t_0$ from~$t_1$.

\paragraph{Example Message Algebra.}

The signature of the order-sorted~\cite{GoguenMeseguer92} algebra used
for examples is in Figure~\ref{fig:signature}.  The algebra of
interest is the order-sorted quotient term algebra generated by an
infinite set of variables.  The set of messages~{\msg} is the carrier
set for sort \srt{M}.  The set of atoms~{\atm} is the union of the
carrier sets for sorts \srt{A}, \srt{S}, and \srt{D}.  We write $t\typ
S$ to say that term~$t$ is in the carrier set of sort~$S$.

\begin{figure}
$$\begin{array}{ll@{{}\colon{}}ll}
\mbox{Sorts:}&
\multicolumn{3}{l}{\mbox{\srt{M}, \srt{A}, \srt{S}, \srt{D}}}\\
\mbox{Subsorts:}&
\multicolumn{3}{l}{\mbox{$\srt{A}<\srt{M}$, $\srt{S}<\srt{M}$,
    $\srt{D}<\srt{M}$}}\\
\mbox{Operations:}&(\cdot,\cdot)&\srt{M}\times\srt{M}\to\srt{M}
&\mbox{Pairing}\\
&\enc{\cdot}{(\cdot)}&\srt{M}\times\srt{A}\to\srt{M}
&\mbox{Asymmetric encryption}\\
&\enc{\cdot}{(\cdot)}&\srt{M}\times\srt{S}\to\srt{M}
&\mbox{Symmetric encryption}\\
&(\cdot)^{-1}&\srt{A}\to\srt{A}
&\mbox{Asymmetric key inverse}\\
\mbox{Equations:}&\multicolumn{3}{l}{(x^{-1})^{-1}=x\mbox{ for $x:\srt{A}$}}
\end{array}$$
\caption{Simple Crypto Algebra Signature}\label{fig:signature}
\end{figure}

The set of variables that occur in term~$t$ is $\vars(t)$.  Each
variable~$x$ in an order-sorted term has a unique sort~$S$.  The
\emph{declaration} of~$x$ is $x\typ S$.  A variable of sort~\srt{M} is
called a \emph{non-atomic variable}.

A message~$t_0$ is \emph{carried by}~$t_1$, written $t_0\sqsubseteq
t_1$ if~$t_0$ can be derived from~$t_1$ given the right set of keys,
that is $\sqsubseteq$ is the smallest reflexive, transitive relation
such that $t_0\sqsubseteq t_0$, $t_0\sqsubseteq (t_0, t_1)$,
$t_1\sqsubseteq (t_0, t_1)$, and $t_0\sqsubseteq\enc{t_0}{t_1}$.

\paragraph{Strand Spaces.}
A run of a protocol is viewed as an exchange of messages by a finite
set of local sessions of the protocol.  Each local session is called a
strand.  The behavior of a strand, its \emph{trace}, is a finite
non-empty sequence of messaging events.  An \emph{event} is either a
message transmission or a reception.  Outbound message $t\in\msg$ is
written as~$\outbnd t$, and inbound message~$t$ is written as~$\inbnd
t$.  The set of traces over $\msg$ is $\tr=(\pm\msg)^+$.  A message
\emph{originates} in trace~$c$ at index~$i$ if it is carried by
$c(i)$, $c(i)$ is outbound, and it is not carried by any event earlier
in the trace.  A message is \emph{acquired} in trace~$c$ if there is
an index~$i$ at which it is carried by $c(i)$, $c(i)$ is inbound, and
it does not occur in any event earlier in the trace.  For algebra
homomorphism~$\sigma$, \[\sigma\circ\seq{\pm t_0,\ldots,\pm t_{n-1}}=
\seq{\pm \sigma(t_0),\ldots,\pm \sigma(t_{n-1})},\]
and $\sigma\circ\prefix{c}{h}=\sigma\circ(\prefix{c}{h})$.

A \emph{strand space}~{\ssp} is a finite non-empty sequence of traces
in $\tr$.  A \emph{strand}~$s$ is in $\strands(\ssp)=\sdom(\ssp)$, the
domain of $\ssp$, and its trace is $\ssp(s)$.  An atom~$t$ is
\emph{non-originating} in a strand space~$\ssp$, written
$\fn{non}(\ssp,t)$, if it originates on no strand.

Message events occur at nodes in a strand space.  For each strand~$s$,
there is a node for every event in~$\ssp(s)$.  The \emph{nodes} of
strand space $\ssp$ are $\nodes(\ssp)=\{(s,i)\mid s\in\strands(\ssp),
i < |\ssp(s)|\}$, and the event at a node is
$\evt_\ssp(s,i)=\ssp(s)(i)$.  A node names an event in a strand space.
The relation~$\Rightarrow$ defined by $\{(s,i)\Rightarrow(s,i+1)\mid
s\in\strands(\ssp), i<|\ssp(s)|-1\}$ is called the \emph{strand
  succession relation}.  An atom~$t$ \emph{uniquely originates} in a
strand space~$\ssp$ at node~$n$, written $\fn{uniq}(\ssp,t,n)$, if it
originates in the trace of exactly one strand~$s$ at index~$i$, and
$n=(s,i)$.

\paragraph{Bundles.}
The pair $\bun=(\ssp,\to)$ is a \emph{bundle} if it defines a directed
acyclic graph, where the vertices are the nodes of $\ssp$, and an edge
represents communication~($\rightarrow$) or strand
succession~($\Rightarrow$) in~$\ssp$.  For communication, if
$n_0\rightarrow n_1$, then there is a message~$t$ such
that~$\evt_\ssp(n_0)=\outbnd t$ and~$\evt_\ssp(n_1)=\inbnd t$.  For
each reception node~$n_1$, there is a unique transmission node~$n_0$
with $n_0\rightarrow n_1$.

Each acyclic graph has a transitive irreflexive relation~$\prec$ on
its vertices.  The relation specifies the causal ordering of nodes in
a bundle.  A transitive irreflexive binary relation is also called a
strict order.

The strand space of bundle~{\bun} is written~$\bun^\ssp$ and its
communication relation is~$\bun^\to$, so
$\bun=(\bun^\ssp,\bun^\to)$.

\paragraph{Runs of Protocols.}
In a run of a protocol, the behavior of each strand is constrained by
a role in a protocol.  Adversarial strands are constrained by roles as
are non-adversarial strands.  A \emph{proto-role} is of the form
$\role(c,\nu,\upsilon)$, where $c\in\tr$, $\nu\in\pow{\atm}^+$,
$\upsilon\in\pow{\atm}^+$, every non-atomic variable in~$c$ is
acquired, and the lengths of $c$, $\nu$, and $\upsilon$ agree.  The
trace of the role is~$c$, its non-origination assumptions are~$\nu$,
and its unique origination assumptions are~$\upsilon$.  A proto-role
$\role(c,\nu,\upsilon)$ is a \emph{role} iff
\begin{enumerate}
\item for all $i<|\nu|$, $t\in \nu(i)$ implies
  $\vars(t)\subseteq\vars(\prefix{c}{i+1})$, and
\item for all $i<|\upsilon|$, $t\in \upsilon(i)$ implies
  $t$ originates in~$c$ at~$i$.
\end{enumerate}

A strand is an instance of a role in a strand space, written
$\fn{inst}(\ssp,s,\role(c,\nu,\upsilon))$, if for $h=|\ssp(s)|$ and
some substitution~$\sigma$,
\begin{enumerate}
\item $h\leq|c|$,
\item $\prefix{\sigma(c)}{h}=\ssp(s)$,
\item for all $i<h$, $t\in \nu(i)$ implies $\fn{non}(\ssp,\sigma(t))$, and
\item for all $i<h$, $t\in \upsilon(i)$ implies
  $\fn{uniq}(\ssp,\sigma(t),(s,i))$.
\end{enumerate}
Let $\role^c(\role(c,\nu,\upsilon))=c$,
$\role^\nu(\role(c,\nu,\upsilon))=\nu$, and
$\role^\upsilon(\role(c,\nu,\upsilon))=\upsilon$.

A \emph{protocol} is a set of roles.  A bundle~$\bun=(\ssp,\to)$ is a
\emph{run of protocol} $P$ if there is a role assignment
$\rl\typ\strands(\ssp)\to P$ such that for each $s\in\strands(\ssp)$,
there exists $r\in\rl(s)$ such that $\fn{inst}(\ssp,s,r)$.
Let~$\run_P$ be the set of bundles that are runs of protocol~$P$.

In each run of a protocol, no non-atomic variables occur.  This a
result of, and the purpose of the constraint on the trace of a role
that every non-atomic variable in the trace is acquired.

\begin{figure}
$$\begin{array}{r@{{}={}}ll}
\fn{create}&\seq{\outbnd x}&
\mbox{$x\typ\srt{A}$ or $x\typ\srt{S}$ or $x\typ\srt{D}$}\\
\fn{pair}&
\seq{\inbnd x,\inbnd y,\outbnd (x,y)}&
x,y\typ\srt{M}\\
\fn{sep}&
\seq{\inbnd (x,y),\outbnd x,\outbnd y}&
x,y\typ\srt{M}\\
\fn{aenc}&
\seq{\inbnd x,\inbnd k,\outbnd \enc{x}{k}}&
\mbox{$x\typ\srt{M}$ and $k\typ\srt{A}$}\\
\fn{adec}&
\seq{\inbnd \enc{x}{k},\inbnd\invk{k},\outbnd x}&
\mbox{$x\typ\srt{M}$ and $k\typ\srt{A}$}\\
\fn{senc}&
\seq{\inbnd x,\inbnd k,\outbnd \enc{x}{k}}&
\mbox{$x\typ\srt{M}$ and $k\typ\srt{S}$}\\
\fn{sdec}&
\seq{\inbnd \enc{x}{k},\inbnd k,\outbnd x}&
\mbox{$x\typ\srt{M}$ and $k\typ\srt{S}$}
\end{array}$$
\caption{Adversary Traces}\label{fig:adversary}
\end{figure}

\paragraph{Adversary Model.}
The traces of the roles that constrain adversarial
behavior are in Figure~\ref{fig:adversary}.  There are no origination
assumptions in the adversary's roles.

There are three \fn{create} roles, one for each sort of atoms.  In
fact, the defining characteristic of an atom is it denotes the set of
messages the adversary can create out of thin air modulo origination
assumptions.

\paragraph{Skeletons.}

A skeleton represents all or part of the regular portion of a bundle.
A skeleton contains a strand space, a partial ordering of its nodes,
assumptions about uncompromised keys and freshly generated atoms, and
role assignment.  The structure of a skeleton used here is motivated
by CPSA~\cite{cpsa09}.

In {\cpsa} syntax, the trace and the role associated with a strand is
specified by an \index{instance}\emph{instance}.  An instance is of
the form $\insta(r,h,\sigma)$, where~$r$ is a role, $h$ specifies the
length of a trace instantiated from the role, and~$\sigma$ specifies
how to instantiate the variables in the role to obtain the trace.
Thus the trace associated with $\insta(r,h,\sigma)$ is
$\sigma\circ\prefix{\role^c(r)}{h}$, the prefix of length~$h$ that
results from applying~$\sigma$ to~$r$.  We assume~$h$ is always less
than or equal to the length of the trace of~$r$.

A sequence of instances~$\insts$ defines a strand space~{\ssp} and a
role assignment~{\rl} when $|\insts|=|\ssp|$, and for
$s\in\strands(\ssp)$, $\insts(s)=\insta(r,h,\sigma)$ implies
$\rl(s)=r$ and $\ssp(s)=\sigma\circ\prefix{\role^c(r)}{h}$.  Let
$\insts^\ssp$ and $\insts^{\rl}$ be the strand space and role
assignment associated with~$\insts$.

A $k=\skel(P,\insts,\prec,\nu,\upsilon)$ is a \emph{skeleton} iff
\begin{enumerate}
\item the range of $\insts^{\rl}$ is $P$,
\item $s\in\strands(\insts^\ssp)$ and $\insts(s)=\insta(r,h,\sigma)$
  implies $\fn{inst}(\insts^\ssp, s, r)$,
\item $\prec$ is a strict order on $\nodes(\insts^\ssp)$,
\item $\nu\subseteq\atm$ and $\upsilon\subseteq\atm$,
\item $t\in\nu$ implies $t$ is not carried in $\insts^\ssp$ and
  $\vars(t)\subseteq\vars(\insts^\ssp)$, and
\item $t\in\upsilon$ implies $t$ originates in at most one trace in
  $\insts^\ssp$.
\end{enumerate}

\paragraph{Homomorphisms.}

Let $k_0=\skel(P,\insts_0,\prec_0,\nu_0,\upsilon_0)$ and
$k_1=\skel(P,\insts_1,\prec_1,\nu_1,\upsilon_1)$ be skeletons,
and let $\ssp_0=\insts^\ssp_0$ and $\ssp_1=\insts^\ssp_1$.  There is a
\emph{skeleton homomorphism} $(\phi,\sigma)\colon k_0\mapsto k_1$
if~$\phi$ and~$\sigma$ are maps with the following properties:
\begin{enumerate}
\item $\phi$ maps strands of~$k_0$ into those of~$k_1$, and nodes as
  $\phi((s,i))=(\phi(s),i)$, that is $\phi$ is in
  $\strands(\ssp_0)\to\strands(\ssp_1)$;
\item $\sigma\colon\alg{A}\to\alg{A}$ is a message algebra homomorphism;
\item $n\in\nodes(\ssp_0)$ implies
  $\sigma(\evt_{\ssp_0}(n))=\evt_{\ssp_1}(\phi(n))$;
\item $n_0\prec_0
n_1$ implies $\phi(n_0)\prec_1\phi(n_1)$;
\item $\sigma(\nu_0)\subseteq \nu_1$;
\item $\sigma(\upsilon_0)\subseteq \upsilon_1$;
\item\label{item:orig} $t\in \upsilon_0$ implies
  $\phi(\orig_{k_0}(t))\subseteq\orig_{k_1}(\sigma(t))$;
\end{enumerate}
where $\orig_k(t)$ is the set of nodes of events at which~$t$
originates.  Property~\ref{item:orig} says the node at which an atom
is declared to be uniquely originating is preserved by homomorphisms.

Notice that the existence of a homomorphism depends only on a
skeleton's strand space, node orderings, non-originating atoms, and
its uniquely originating atoms.  A bundle~{\bun} can be the target of
a homomorphism using its strand space, node orderings, non-originating
atoms $\{t\mid \fn{non}(\bun^\ssp,t)\}$, and its uniquely originating
atoms $\{t\mid\some{n\in\nodes(\bun^\ssp)}\fn{uniq}(\bun^\ssp,t,n)\}$.
The set of bundles associated with skeleton~$k$ is
\(\sembrack{k}=\{\bun\mid\some{\phi,\sigma}(\phi,\sigma)\colon
k\mapsto\bun\}.\)

\section{Shape Analysis Sentences}\label{sec:shape analysis sentences}

Given the definitions in the previous section, the language~$\lang(P)$
used for shape analysis sentences is quite constrained.
The signature for terms extends the one used for the underlying
message algebra with a sort~$\srt{N}$, the sort of natural numbers,
and two new operations, constant $\mathsf{zero}\typ\srt{N}$, and the
successor function $\mathsf{succ}\typ\srt{N}\to\srt{N}$.  The text
uses the usual numerals for natural numbers.  Variables of this sort
will denote strands.

Shape formulas make use of protocol specific predicates and protocol
independent predicates.  For each role~$r\in P$, $1\leq h\leq|r|$, and
variable~$x\typ S$ that occurs in $\prefix{r}{h}$, there is a protocol
specific binary predicate $P[r,h,x]\typ\srt{N}\times S$.  For reasons
that will become evident when their semantics is defined, each
protocol specific predicate is called a \emph{strand progress
  predicate}. The protocol independent predicate of arity four is
$\mathsf{prec}\typ\srt{N}\times\srt{N}\times\srt{N}\times\srt{N}$.
The protocol independent unary predicates are $\mathsf{non}\typ B$ for
each atomic sort~$B\in\{\srt{A}, \srt{S},\srt{D}\}$, and the protocol
independent ternary predicates are $\mathsf{uniq}\typ
B\times\srt{N}\times\srt{N}$.
Finally, equality is binary.

We define~$\form(k)=(Y,\Phi)$, where~$\Phi$ is $k$'s skeleton formula,
and~$Y$ is the formula's variable declarations.  Let
$k=\skel(P,\insts,\prec,\nu,\upsilon)$.  The declarations~$Y$ is the
declarations of $\vars(\insts^\ssp)$ augmented with a fresh
variable~$z_s\typ\srt{N}$ for each strand $s\in\sdom(I)$.  The
formula~$\Phi$ is a conjunction of atomic formulas composed as
follows.

\begin{itemize}
\item For each $s\in\sdom(I)$, let $I(s)=\insta(r,h,\sigma)$.  For
  each variable $x\in\vars(\prefix{r}{h})$ and term $t=\sigma(x)$, assert
  $P[r,h,x](z_s,t)$.
\item For each $(s,i)\prec(s',i')$, assert
  $\cn{prec}(z_s,i,z_{s'},i')$.
\item For each $t\in\nu$, assert $\cn{non}(t)$.
\item For each $t\in\upsilon$ and $(s,i)\in\orig_k(t)$, assert
  $\cn{uniq}(t,z_s, i)$.
\end{itemize}

The structure of a generated formula has a notable property.  Each
$z\typ\srt{N}$ is associated with a unique role that is determined by
one or more atomic formulas of the form $P[r,\ast,\ast](z,\ast)$.
This property will be used in Section~\ref{sec:protocol injections}.

Given a set of homomorphisms $\delta_i\typ k_0\mapsto k_i$, its shape
analysis sentence is
\begin{equation}\label{eqn:shape sentence}
\sent(\delta_i\typ k_0\mapsto k_i)=\all{X_0}(\Phi_0\supset
\bigvee_i\some{X_i}(\Delta_i\wedge\Phi_i)),
\end{equation}
where $\form(k_0)=(X_0,\Phi_0)$.  The same procedure produces~$X_i$
and~$\Phi_i$ for shape~$k_i$ with one proviso---the variables in
$X_i$ that also occur in~$X_0$ must be renamed to avoid trouble while
encoding the structure preserving maps~$\delta_i$.

The structure preserving maps~$\delta_i=(\phi_i,\sigma_i)$ are encoded
in~$\Delta_i$ by a conjunction of equalities.  Map~$\sigma_i$ is coded
as equalities between a message algebra variable in the domain
of~$\sigma_i$ and the term it maps to.  Map~$\phi_i$ is coded as
equalities between strand variables in~$\Phi_0$ and strand variables
in~$\Phi_i$.  Let~$Z_0$ be the sequence of strand variables freshly
generated for~$k_0$, and~$Z_i$ be the ones generated for~$k_i$.  The
strand mapping part of~$\Delta_i$ is
$\bigwedge_{j\in\sdom(\Theta)}Z_0(j)=Z_i(\phi_i(j))$.

\paragraph{Semantics of Skeleton Formulas.}

Let $k=\skel_X(P,\insts,\prec,\nu,\upsilon)$.  The universe of discourse is
$\alg{D}=\nat\cup\msg$.  When formula~$\Phi$ is satisfied in
skeleton~$k$ with variable assignment $\alpha\colon Y\to \alg{D}$, we
write $k,\alpha\models\Phi$.  When sentence~$\Gamma$ is satisfied in
skeleton~$k$, we write $k\models\Gamma$.

For each protocol specific predicate $P[r,h,x]$, $k,\alpha\models
P[r,h,x](y,z)$ iff $\alpha(y)\in\nat$, $\alpha(z)\in\msg$, and with
$\alpha(y)=s$,

\begin{enumerate}
\item $s\in\strands(\ssp)$,
\item $h\leq|\ssp(s)|$, and
\item $\prefix{\ssp(s)}{h}=\sigma\circ\{x\mapsto\alpha(z)\}\circ\prefix{r}{h}$
  for some~$\sigma$.
\end{enumerate}

In an interpretation, $\rl(s)$ need not be~$r$.  The events that make
up a strand's trace is all that matters.  The protocol specific
predicate $P[r,h,x]$ is called a strand progress predicate, because it
asserts a strand is compatible with an instance of role~$r$ of height
at least~$h$.

The interpretation of the protocol independent predicates is
straightforward.
\begin{itemize}
\item $k,\alpha\models\cn{prec}(w,x,y,z)$ iff
$(\alpha(w),\alpha(x))\prec(\alpha(y),\alpha(z))$.
\item $k,\alpha\models\cn{non}(y)$ iff $\alpha(y)\in N$.
\item $k,\alpha\models\cn{uniq}(x,y,z)$ iff $\alpha(x)\in U$ and
  $(\alpha(y),\alpha(z))\in\orig_k(\alpha(x))$.
\item $k,\alpha\models y=z$ iff $\alpha(y)=\alpha(z)$.
\end{itemize}

\begin{thm}\label{thm:skeleton models}
Let $\form(k_0)=(X,\Phi)$ and $\Gamma=\some{X}\Phi$.  Sentence~$\Gamma$ is
satisfied in~$k$ iff there is a homomorphism from~$k_0$ to
$k$, i.e.\ $k\models\Gamma$ iff
$\some{\delta}\delta\colon k_0\mapsto k$.
\end{thm}

\begin{proof}
For the forward direction, assume~$\alpha$ is a variable assignment
for the variables in~$X$ such that $k,\alpha\models\Phi$, and let~$Z$
be the sequence of strand variables constructed while
generating~$\Phi$ from~$k_0$.  Then the pair of maps
$\delta=(\alpha\circ Z,\alpha)$ demonstrate a homomorphism from~$k_0$
to~$k$, i.e.\ each item in the definition of a skeleton homomorphism
in Section~\ref{sec:strand spaces} is satisfied.

For the reverse direction, assume maps $\delta=(\phi,\sigma)$ are such
that $\delta\colon k_0\mapsto k$.  Then the desired variable assigment is
$$\alpha(x)=\left\{
\begin{array}{ll}
\phi(Z^{-1}(x))&x\in\sran(Z)\\
\sigma(x)&x\in\sdom(\sigma).
\end{array}\right.$$
\end{proof}

\paragraph{Deducing Security Goals.}  A shape analysis $\delta_i\colon
k_0\mapsto k_i$ is \emph{complete} if for each realized skeleton~$k$,
$\delta\colon k_0\mapsto k\mbox{ iff }\some{i,\delta'}\delta'\colon
k_i\mapsto k$.  The next theorem captures the sense in which a shape
analysis sentence characterizes a complete shape analysis.

\begin{thm}\label{thm:sentence implies}
Let $\delta_i\colon k_0\mapsto k_i$ be a complete shape analysis.
Then the shape analysis sentence~$\Gamma=\sent(\delta_i\colon
k_0\mapsto k_i)$ is satisfied in all realized skeletons~$k$,
i.e.\ $k\models\Gamma$.
\end{thm}

\begin{proof}
Shapes are minimal among realized skeletons, so there is no realized
skeleton in the image of~$k$ that is not in the image of one of the
shapes.  Therefore, by Theorem~\ref{thm:skeleton models}, the negation
of the hypothesis of the implication is satisfied in all realized
skeletons that are not in the image of~$k_0$, and the disjunction is
satisfied in the remaining realized skeletons.
\end{proof}

A \emph{security formula}~$\Psi$ for protocol~$P$ is a first-order
formula over the language~$\lang(P)$ that shares a property with shape
analysis sentences.  Each $z\typ\srt{N}$ in~$\Psi$ is associated with a
unique role that is determined by one or more atomic formulas of the form
$P[r,\ast,\ast](z,\ast)$.

Let~$\Gamma$ be the shape analysis sentence of a complete shape
analysis and~$\Psi$ be a security formula.  If $\Gamma\supset\Psi$ is a
theorem in order-sorted first-order logic, then~$\Psi$ is satisfied in
all realized skeletons and its protocol achieves this goal.  It is
also satisfied in all bundles.

\section{Protocol Injections}\label{sec:protocol injections}

A function $f\in\zed_m\to\zed_n$ is \emph{increasing} iff $i<j$
implies $f(i)<f(j)$.  The set of such functions is~$\alg{F}[m,n]$.  An
increasing function is injective.

A \emph{trace stretch} from trace~$c_0$ to~$c_1$ is a pair containing
an increasing function $f\in\alg{F}[|c_0|, |c_1|]$ and an injective
function $\gamma\in\vars(c_0)\to\vars(c_1)$ such that for all~$i$,
$c(i)$ is inbound iff $c(f(i))$ is inbound.  The set of such pairs
is~$\alg{T}[c_0,c_1]$.  A \emph{strand stretch} from strand
space~$\ssp_0$ to~$\ssp_1$ is an increasing function
$h^s\in\alg{F}[|\ssp_0|, |\ssp_1|]$.

The set of \emph{protocol injections} from protocol~$P_0$ to~$P_1$ is
\[\alg{P}[P_0,P_1]=\dprod{\role(c_0,\nu_0,\upsilon_0)\in
  P_0}\dpair{\role(c_1,\nu_1,\upsilon_1)\in P_1}\alg{T}[c_0,c_1].\]
That is, if~$g\in\alg{P}[P_0,P_1]$ and~$r_0\in P_0$, then
$g(r_0)=(r_1,f,\gamma)$, where $r_1\in P_1$ and~$(f,\gamma)$ is a
trace stretch from the trace of~$r_0$ to the trace of~$r_1$.  The role
map of a protocol injection~$g$ is written~$g^r$ and the role to trace
stretch is written~$g^f$ and~$g^\gamma$, so $g(r_0)=(g^r(r_0),
g^f(r_0),g^\gamma(r_0))$.

\paragraph{Goal Imports.}
Protocol injections can be used to decide if the security goals of one
protocol are imported into another.  The definition of goal
importation ensures that the truth of predicates used in security
formulas is preserved.

Let $\Psi$ be a security formula for protocol~$P_0$ and
$g\in\alg{P}[P_0,P_1]$ be a protocol injection.  To import~$\Psi$
into~$P_1$, transform each atomic formula in~$\Psi$ as follows.
\begin{itemize}
\item $P_0[r,h,x](z, t)$ becomes
  $P_1[g^r(r),g^f(r)(h),g^\gamma(r)(x)](z,t)$.
\item $\cn{prec}(z,i,z',i')$ becomes
  $\cn{prec}(z,g^f(r)(i),z',g^f(r')(i'))$, where both\\
  $P_0[r,\ast,\ast](z,\ast)$ and
  $P_0[r',\ast,\ast](z',\ast)$ occur in~$\Psi$.
\item Otherwise, the atomic formula is not changed.
\end{itemize}

In what follows, Properties~\ref{item: role mappings} and~\ref{item:
  role heights} ensure the preservation of the truth of strand
progress predicates.  Property~\ref{item: node orderings} ensures the
truth of~$\prec$ is preserved.  Properties~\ref{item: nons}
and~\ref{item: uniques} ensure the truths of \fn{non} and \fn{uniq}
are preserved.

A protocol~$P_1$ \emph{imports the goals} of protocol~$P_0$, written
$P_1\unrhd P_0$, iff
\begin{itemize}
\item there exists a protocol injection $g\in\alg{P}[P_0,P_1]$ such
  that
\item for all bundles~$\bun_1$ that are runs of~$P_1$ with role
  assignment~$\rl_1$, there exists
  \begin{itemize}
  \item bundle~$\bun_0$ that is a run of~$P_0$ with role
    assignment~$\rl_0$, and
  \item strand stretch $h^s\in\alg{F}[|\ssp_0|, |\ssp_1|]$,
  \end{itemize}
  where $\ssp_0=\bun^\ssp_0$ and $\ssp_1=\bun^\ssp_1$, and the following
  conditions hold.
\end{itemize}
\begin{enumerate}

\item\label{item: role mappings} Roles respect injection (for role
  predicate mappings).
  \[\begin{array}{l}
  \all{s_0\in\strands(\ssp_0),s_1\in\strands(\ssp_1)}h^s(s_0) = s_1\\
  \quad\supset g^r(\rl_0(s_0))=\rl_1(s_1)\\
  \qquad{}\land\sigma\circ\gamma\circ\prefix{c_0}{|\ssp_0(s_0)|}
  = \ssp_0(s_0)
  \end{array}\]
  where $c_0=\role^c(\rl_0(s_0))$,
  $\gamma=g^\gamma(\rl_0(s_0))$, and~$\sigma$ is the substitution that
  shows that~$s_1$ is an instance of its role, i.e.\@
  $\sigma\circ\prefix{c_1}{|\ssp_1(s_1)|}=\ssp_1(s_1)$ for
  $c_1=\role^c(\rl_1(s_1))$.

\item\label{item: role heights} Nodes respect injection (for role
  predicate heights).
  \[n_0\in\nodes(\ssp_0)\mbox{ iff }\some{n_1\in\nodes(\ssp_1)}\ell(n_0)=n_1\]
  where $\ell(s,i)=(h^s(s),g^f(\rl_0(s))(i))$.

\item\label{item: node orderings} Source communication edges repect
  injection (for node ordering predicate).  For
  $n_0,n_2\in\nodes(\ssp_0)$, $n_0\mathbin{\bun^\to_0} n_2$ iff
  \[\some{n_1,n_3\in\nodes(\ssp_1)}\ell(n_0)=n_1\land\ell(n_2)=n_3\land
  n_1\mathbin{\bun^\to_1} n_3\]

\item\label{item: nons} Non-origination predicate respects injection.
  Let~$\atm$ be the atoms that occur in~$\bun_0$.
  \[\all{t\in\atm}\fn{non}(\bun_1^\ssp, t)\supset\fn{non}(\bun_0^\ssp, t)\]

\item\label{item: uniques} Unique origination predicate respects injection.
  \[\all{t\in\atm,n\in\nodes(\bun_0^\ssp)}\fn{uniq}(\bun_1^\ssp,
  t,\ell(n))\supset\fn{uniq}(\bun_0^\ssp, t,n)\]
\end{enumerate}

Note that above definition is constructive in that given an
injection~$g$ and a bundle~$\bun_1$, it describes how to
create~$\bun_0$, $h^s$, and $h^n$ that can then be used for
evaluation.

\bibliography{secureprotocols}
\bibliographystyle{plain}

\end{document}
