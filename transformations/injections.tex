\documentclass[12pt]{article}

\newif\ifreleased
\releasedtrue % \releasedfalse

% For drafts:
\ifreleased
\else
\pagestyle{myheadings}
\markright{Draft of \today{}}
\fi
%\renewcommand{\pagename}{Draft of \today{}, Page}

%\usepackage{graphics}
%\usepackage[matrix,arrow,curve]{xy}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{url}
\usepackage{hyperref}\hypersetup{colorlinks=true,}

\newenvironment{note}{\begingroup\itshape}{\endgroup}
\newcommand{\remark}[1]{\emph{[#1]}}
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{conj}[thm]{Conjecture}
\newcommand{\cpsa}{\textsc{cpsa}}
\newcommand{\pvs}{\textsc{pvs}}
\newcommand{\cn}[1]{\ensuremath{\operatorname{\mathsf{#1}}}}
\newcommand{\dom}[1]{\ensuremath{\operatorname{\mathbf{#1}}}}
\newcommand{\fn}[1]{\ensuremath{\operatorname{\mathit{#1}}}}
\newcommand{\srt}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\typ}{\mathbin:}
\newcommand{\sdom}{\fn{Dom}}
\newcommand{\sran}{\fn{Ran}}
\newcommand{\vars}{\fn{Vars}}
\newcommand{\seq}[1]{\ensuremath{\langle#1\rangle}}
\newcommand{\prefix}[2]{#1\dagger#2}
\newcommand{\append}{\cdot}
\newcommand{\enc}[2]{\ensuremath{\{\!|#1|\!\}_{#2}}}
\newcommand{\invk}[1]{{#1}^{-1}}
\newcommand{\inbnd}{\mathord -}
\newcommand{\outbnd}{\mathord +}
\newcommand{\nat}{\ensuremath{\mathbb{N}}}
\newcommand{\zed}{\ensuremath{\mathbb{Z}}}
\newcommand{\all}[1]{\forall#1\mathpunct.}
\newcommand{\some}[1]{\exists#1\mathpunct.}
\newcommand{\funct}[1]{\lambda#1\mathpunct.}
\newcommand{\dprod}[1]{\Pi_{(#1)}}
\newcommand{\dpair}[1]{\Sigma_{(#1)}}
\newcommand{\pow}[1]{\wp(#1)}

\newcommand{\alg}[1]{\ensuremath{\mathfrak{#1}}}
\newcommand{\msg}{\alg{A}}
\newcommand{\atm}{\alg{B}}
\newcommand{\ssp}{\ensuremath{\mathcal{S}}}
\newcommand{\bun}{\ensuremath{\mathcal{B}}}
\newcommand{\strands}{\ensuremath{\mathcal{Z}}}
\newcommand{\nodes}{\ensuremath{\mathcal{N}}}
\newcommand{\pos}{\ensuremath{\mathcal{P}}}

\newcommand{\run}{\mathcal{R}}
\newcommand{\pt}{\fn{pt}}
\newcommand{\form}{\mathcal{K}}
\newcommand{\sent}{\mathcal{S}}
\newcommand{\lang}{\mathcal{L}}
\newcommand{\interp}{\mathcal{I}}
\newcommand{\tr}{\ensuremath{\mathfrak C}}
\newcommand{\rl}{\fn{rl}}
\newcommand{\skel}{\mathsf{k}}
\newcommand{\insta}{\mathsf{i}}
\newcommand{\evt}{\fn{evt}}
\newcommand{\role}{\mathsf{r}}
\newcommand{\orig}{\mathcal{O}}

\newcommand{\boot}{\cn{b}}
\newcommand{\extend}{\cn{ex}(\cn{d},\boot)}
\newcommand{\tran}{\ensuremath{\tau}}
\newcommand{\pth}{\ensuremath{\pi}}
\newcommand{\type}{\ensuremath{\mathfrak T}}
\newcommand{\up}{\mathord\uparrow}
\newcommand{\down}{\mathord\downarrow}

\title{Protocol Injections}
\author{John D.\ Ramsdell}
%\institute{The MITRE Corporation}

\begin{document}
\maketitle

\section{Introduction}

This paper introduces protocol injections.  Protocol injections are
related to protocol transformations~\cite{Guttman12a} as shape
analysis sentences~\cite{Ramsdell12} are related to security goals as
defined in~\cite{Guttman12a}.  The precise relation between protocol
injections and transformations has yet to be established.

Protocol injections can be used to decide if the security goals of one
protocol are imported into another.  The definition of goal
importation defined in Section~\ref{sec:protocol injections} ensures
that the truth of predicates used in shape analysis sentences is
preserved.

\paragraph{Notation.}

A finite sequence~$f$ is a function from an initial segment of the
natural numbers.  The length of~$f$ is~$|f|$, and $f=\seq{f(0),\ldots,
  f(n-1)}$ for $n=|f|$.  If~$S$ is a set, then~$S^\ast$ is the set of
finite sequences over~$S$, and~$S^+$ is the non-empty finite sequences
over~$S$.  The concatenation of sequences~$f_0$ and~$f_1$
is~$f_0\append f_1$.  The prefix of sequence~$f$ of length~$n$
is~$\prefix{f}{n}$.

{\pvs} is based on classical, typed higher-order
logic.  It has dependent types and parameterized theories.
The dependent product type~$\dprod{x\in A}B(x)$ has the property that 
$f\in\dprod{x\in A}B(x)$ implies that for~$x\in A$, $f(x)\in B(x)$.
The dependent pair type~$\dpair{x\in A}B(x)$ has the property that 
$(x,y)\in\dpair{x\in A}B(x)$ implies that~$x\in A$ and~$y\in B(x)$.

\section{Strand Spaces}\label{sec:strand spaces}

Based on~\cite{cpsaspec09}, this section describes the {\pvs}
definition of strand spaces~\cite{ThayerHerzogGuttman99} in a style
motivated by the {\pvs} language~\cite{cade92-pvs}, that is, the
presentation attempts to minimize the gap between the actual proofs
and this content.

The parameters to the strand space theory are a set of messages
(\msg), a set of atoms ($\atm\subset\msg$), and a carried by relation
(${\sqsubseteq}\subseteq\msg\times\msg$).  The set of messages~{\msg}
is the carrier set of a term algebra.  Keys and nonces are examples of
atoms.  Intuitively, a message~$t_0$ is carried by~$t_1$
($t_0\sqsubseteq t_1$) if it is possible to extract~$t_0$ from~$t_1$.

\paragraph{Example Message Algebra.}

The signature of the order-sorted~\cite{GoguenMeseguer92} algebra used
for examples is in Figure~\ref{fig:signature}.  The algebra of
interest is the order-sorted quotient term algebra generated by an
infinite set of variables.  The set of messages~{\msg} is the carrier
set for sort \srt{M}.  The set of atoms~{\atm} is the union of the
carrier sets for sorts \srt{A}, \srt{S}, and \srt{D}.  Each variable
in an order-sorted term has a unique sort.  A variable of sort~\srt{M}
is called a \emph{non-atomic variable}.

\begin{figure}
$$\begin{array}{ll@{{}\colon{}}ll}
\mbox{Sorts:}&
\multicolumn{3}{l}{\mbox{\srt{M}, \srt{A}, \srt{S}, \srt{D}}}\\
\mbox{Subsorts:}&
\multicolumn{3}{l}{\mbox{$\srt{A}<\srt{M}$, $\srt{S}<\srt{M}$,
    $\srt{D}<\srt{M}$}}\\
\mbox{Operations:}&(\cdot,\cdot)&\srt{M}\times\srt{M}\to\srt{M}
&\mbox{Pairing}\\
&\enc{\cdot}{(\cdot)}&\srt{M}\times\srt{A}\to\srt{M}
&\mbox{Asymmetric encryption}\\
&\enc{\cdot}{(\cdot)}&\srt{M}\times\srt{S}\to\srt{M}
&\mbox{Symmetric encryption}\\
&(\cdot)^{-1}&\srt{A}\to\srt{A}
&\mbox{Asymmetric key inverse}\\
\mbox{Equations:}&\multicolumn{3}{l}{(x^{-1})^{-1}=x\mbox{ for $x:\srt{A}$}}
\end{array}$$
\caption{Simple Crypto Algebra Signature}\label{fig:signature}
\end{figure}

A message~$t_0$ is \emph{carried by}~$t_1$, written $t_0\sqsubseteq
t_1$ if~$t_0$ can be derived from~$t_1$ given the right set of keys,
that is $\sqsubseteq$ is the smallest reflexive, transitive relation
such that $t_0\sqsubseteq t_0$, $t_0\sqsubseteq (t_0, t_1)$,
$t_1\sqsubseteq (t_0, t_1)$, and $t_0\sqsubseteq\enc{t_0}{t_1}$.

\paragraph{Strand Spaces.}
A run of a protocol is viewed as an exchange of messages by a finite
set of local sessions of the protocol.  Each local session is called a
strand.  The behavior of a strand, its \emph{trace}, is a finite
non-empty sequence of messaging events.  An \emph{event} is either a
message transmission or a reception.  Outbound message $t\in\msg$ is
written as~$\outbnd t$, and inbound message~$t$ is written as~$\inbnd
t$.  The set of traces over $\msg$ is $\tr=(\pm\msg)^+$.  A message
\emph{originates} in trace~$c$ at index~$i$ if it is carried by
$c(i)$, $c(i)$ is outbound, and it is not carried by any event earlier
in the trace.  A message is \emph{acquired} in trace~$c$ if there is
an index~$i$ at which it is carried by $c(i)$, $c(i)$ is inbound, and
it does not occur in any event earlier in the trace.  For algebra
homomorphism~$\sigma$, \[\sigma (\seq{\pm t_0,\ldots,\pm t_{n-1}})=
\seq{\pm \sigma(t_0),\ldots,\pm \sigma(t_{n-1})}.\]

A \emph{strand space}~{\ssp} is a finite non-empty sequence of traces
in $\tr$.  A \emph{strand}~$s$ is in $\strands(\ssp)=\sdom(\ssp)$, the
domain of $\ssp$, and its trace is $\ssp(s)$.  An atom~$t$ is
\emph{non-originating} in a strand space~$\ssp$, written
$\fn{non}(\ssp,t)$, if it originates on no strand.

Message events occur at nodes in a strand space.  For each strand~$s$,
there is a node for every event in~$\ssp(s)$.  The \emph{nodes} of
strand space $\ssp$ are $\nodes(\ssp)=\{(s,i)\mid s\in\strands(\ssp),
i < |\ssp(s)|\}$, and the event at a node is
$\evt_\ssp(s,i)=\ssp(s)(i)$.  A node names an event in a strand space.
The relation~$\Rightarrow$ defined by $\{(s,i)\Rightarrow(s,i+1)\mid
s\in\strands(\ssp), i<|\ssp(s)|-1\}$ is called the \emph{strand
  succession relation}.  An atom~$t$ \emph{uniquely originates} in a
strand space~$\ssp$ at node~$n$, written $\fn{uniq}(\ssp,t,n)$, if it
originates in the trace of exactly one strand~$s$ at index~$i$, and
$n=(s,i)$.

\paragraph{Bundles.}
The pair $\bun=(\ssp,\to)$ is a \emph{bundle} if it defines a directed
acyclic graph, where the vertices are the nodes of $\ssp$, and an edge
represents communication~($\rightarrow$) or strand
succession~($\Rightarrow$) in~$\ssp$.  For communication, if
$n_0\rightarrow n_1$, then there is a message~$t$ such
that~$\evt_\ssp(n_0)=\outbnd t$ and~$\evt_\ssp(n_1)=\inbnd t$.  For
each reception node~$n_1$, there is a unique transmission node~$n_0$
with $n_0\rightarrow n_1$.

Each acyclic graph has a transitive irreflexive relation~$\prec$ on
its vertices.  The relation specifies the causal ordering of nodes in
a bundle.  A transitive irreflexive binary relation is also called a
strict order.

The strand space of bundle~{\bun} is written~$\bun^\ssp$ and its
communication relations is~$\bun^\to$, so
$\bun=(\bun^\ssp,\bun^\to)$.

\paragraph{Runs of Protocols.}
In a run of a protocol, the behavior of each strand is constrained by
a role in a protocol.  Adversarial strands are constrained by roles as
are non-adversarial strands.  A \emph{role} is of the form
$\role(c,\nu,\upsilon)$, where $c\in\tr$, $\nu\in\pow{\atm}^+$,
$\upsilon\in\pow{\atm}^+$, every non-atomic variable in~$c$ is
acquired, and the lengths of $c$, $\nu$, and $\upsilon$ agree.  The
trace of the role is~$c$, its non-origination assumptions are~$\nu$,
and its unique origination assumptions are~$\upsilon$.  A strand is an
instance of a role in a strand space, written
$\fn{inst}(\ssp,s,\role(c,\nu,\upsilon))$, if for $h=|\ssp(s)|$ and
some substitution~$\sigma$,
\begin{enumerate}
\item $h\leq|c|$,
\item $\prefix{\sigma(c)}{h}=\ssp(s)$,
\item for all $i<h$, $t\in \nu(i)$ implies $\fn{non}(\ssp,\sigma(t))$, and
\item for all $i<h$, $t\in \upsilon(i)$ implies
  $\fn{uniq}(\ssp,\sigma(t),(s,i))$.
\end{enumerate}
Let $\rho^c(\role(c,\nu,\upsilon))=c$,
$\rho^\nu(\role(c,\nu,\upsilon))=\nu$, and
$\rho^\upsilon(\role(c,\nu,\upsilon))=\upsilon$.

A \emph{protocol} is a set of roles.  A bundle~$\bun=(\ssp,\to)$ is a
\emph{run of protocol} $P$ if there is a role assignment
$\rl\typ\strands(\ssp)\to P$ such that for each $s\in\strands(\ssp)$, there
exists $\role(c,\nu,\upsilon)\in\rl(s)$ such that
$\fn{inst}(\ssp,s,\role(c,\nu,\upsilon))$.  Let~$\run_P$ be the set of
bundles that are runs of protocol~$P$.

\section{Protocol Injections}\label{sec:protocol injections}

A function $f\in\zed_m\to\zed_n$ is \emph{increasing} iff $i<j$
implies $f(i)<f(j)$.  The set of such functions is~$\alg{F}[m,n]$.  An
increasing function is injective.

A \emph{trace stretch} from trace~$c_0$ to~$c_1$ is a pair containing
an increasing function $f\in\alg{F}[|c_0|, |c_1|]$ and an injective
function $\gamma\in\vars(c_0)\to\vars(c_1)$ such that for
all~$i$, $c(i)$ is inbound iff $c(f(i))$ is inbound.  The set of such
pairs is~$\alg{T}[c_0,c_1]$.

A \emph{strand stretch} from strand space~$\ssp_0$ to~$\ssp_1$ is an
increasing function $h^s\in\alg{F}[|\ssp_0|, |\ssp_1|]$.  A \emph{node
  stretch} from strand space~$\ssp_0$ to~$\ssp_1$ using
$h^s\in\alg{F}[|\ssp_0|, |\ssp_1|]$ is an increasing function
$h^n\in\dprod{s\in\strands(\ssp_0)}\alg{F}[|\ssp_0(s)|,
  |\ssp_1(h^s(s))|]$.  That is, for $s\in\strands(\ssp_0)$ and
$i\in\sdom(\ssp_0(s))$, $h^n(s)(i)\in\sdom(\ssp_1(h^s(s))$.  In this
context, the \emph{node implant} is the function in
$\nodes(\ssp_0)\to\nodes(\ssp_1)$ defined by
$\ell(s,i)=(h^s(s), h^n(s)(i))$.

The set of \emph{protocol injections} from protocol~$P_0$ to~$P_1$ is
\[\alg{P}[P_0,P_1]=\dprod{\role(c_0,\nu_0,\upsilon_0)\in
  P_0}\dpair{\role(c_1,\nu_1,\upsilon_1)\in P_1}\alg{T}[c_0,c_1].\]
That is, if~$g\in\alg{P}[P_0,P_1]$ and~$r_0\in P_0$, then
$g(r_0)=(r_1,f,\gamma)$, where $r_1\in P_1$ and~$(f,\gamma)$ is a
trace stretch from the trace of~$r_0$ to the trace of~$r_1$.  The role
map of a protocol injection~$g$ is written~$g^r$ and the role to trace
stretch is written~$g^f$ and~$g^\gamma$, so $g(r_0)=(g^r(r_0),
g^f(r_0),g^\gamma(r_0))$.

\paragraph{Goal Imports.}
Protocol injections can be used to decide if the security goals of one
protocol are imported into another.  The definition of goal
importation ensures that the truth of predicates used in shape
analysis sentences is preserved.

The atomic formulas used in shape analysis sentences are constructed
using the predicates \fn{htin}, $\prec$, \fn{non}, and \fn{uniq},
where 
\[\fn{htin}(\ssp,s,r,h,\sigma)=h\leq|\ssp(s)|\land\fn{inst}(\ssp,s,r)
\land\prefix{\sigma(\rho^c(r))}{h}=\ssp(s).\]
In what follows, Properties~\ref{item: role mappings} and~\ref{item:
  role heights} ensure the preservation of the truth of the \fn{htin}.
Property~\ref{item: node orderings} ensures the truth of~$\prec$ is
preserved.  Properties~\ref{item: nons} and~\ref{item: uniques} ensure
the truths of \fn{non} and \fn{uniq} are preserved.

A protocol~$P_1$ \emph{imports the goals} of protocol~$P_0$, written
$P_1\unrhd P_0$, iff
\begin{itemize}
\item there exists a protocol injection $g\in\alg{P}[P_0,P_1]$ such
  that
\item for all bundles~$\bun_1$ that are runs of~$P_1$ with role
  assignment~$\rl_1$, there exists
  \begin{itemize}
  \item bundle~$\bun_0$ that is a run of~$P_0$ with role
    assignment~$\rl_0$, and
  \item strand stretch $h^s\in\alg{F}[|\ssp_0|, |\ssp_1|]$, and
  \item node stretch
    $h^n\in\dprod{s\in\strands(\ssp_0)}\alg{F}[|\ssp_0(s)|,
    |\ssp_1(h^s(s))|]$,
  \end{itemize}
  where $\ssp_0=\bun^\ssp_0$ and $\ssp_1=\bun^\ssp_1$, and the following
  conditions hold.
\end{itemize}
\begin{enumerate}

\item\label{item: role mappings} Roles respect injection (for role
  predicate mappings).
  \[\begin{array}{l}
  \all{s_0\in\strands(\ssp_0),s_1\in\strands(\ssp_1)}h^s(s_0) = s_1\\
  \quad\supset g^r(\rl_0(s_0))=\rl_1(s_1)\\
  \qquad{}\land\sigma(\prefix{\gamma(c_0)}{|\ssp_0(s_0)|})
  = \ssp_0(s_0)
  \end{array}\]
  where $c_0=\rho^c(\rl_0(s_0))$,
  $\gamma=g^\gamma(\rl_0(s_0))$, and~$\sigma$ is the substitution that
  shows that~$s_1$ is an instance of its role, i.e.\@
  $\sigma(\prefix{c_1}{|\ssp_1(s_1)|})=\ssp_1(s_1)$ for
  $c_1=\rho^c(\rl_1(s_1))$.

\item\label{item: role heights} Nodes respect injection (for role
  predicate heights).
  \[\begin{array}{l}
  \all{(s_0,i_0)\in\nodes(\ssp_0),(s_1,i_1)\in\nodes(\ssp_1)}\\
  \quad h^s(s_0) = s_1\land g^f(\rl_0(s_0))(i_0)=i_1\\
  \qquad{}\supset\ell(s_0,i_0)=(s_1,i_1)
  \end{array}\]

\item\label{item: node orderings} Source communication edges repect
  injection (for node ordering predicate).  For
  $n_0,n_2\in\nodes(\ssp_0)$, $n_0\mathbin{\bun^\to_0} n_2$ iff
  \[\some{n_1,n_3\in\nodes(\ssp_1)}\ell(n_0)=n_1\land\ell(n_2)=n_3\land
  n_1\mathbin{\bun^\to_1} n_3\]

\item\label{item: nons} Non-origination predicate respects injection.
  Let~$\atm$ be the atoms that occur in~$\bun_0$.
  \[\all{t\in\atm}\fn{non}(\bun_1^\ssp, t)\supset\fn{non}(\bun_0^\ssp, t)\]

\item\label{item: uniques} Unique origination predicate respects injection.
  \[\all{t\in\atm,n\in\nodes(\bun_0^\ssp)}\fn{uniq}(\bun_1^\ssp,
  t,\ell(n))\supset\fn{uniq}(\bun_0^\ssp, t,n)\]
\end{enumerate}

Note that above definition is constructive in that given an
injection~$g$ and a bundle~$\bun_1$, it describes how to
create~$\bun_0$, $h^s$, and $h^n$ that can then be used for
evaluation.

\bibliography{secureprotocols}
\bibliographystyle{plain}

\end{document}
